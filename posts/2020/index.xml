<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2020 on すいはんぶろぐ.io</title>
    <link>https://suihan74.github.io/posts/2020/</link>
    <description>Recent content in 2020 on すいはんぶろぐ.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Wed, 15 Jan 2020 01:30:40 +0900</lastBuildDate>
    
	<atom:link href="https://suihan74.github.io/posts/2020/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ダイアログ化したActivityの外側タップを検知する</title>
      <link>https://suihan74.github.io/posts/2020/01_15_00_app_dialog_theme_click_outside/</link>
      <pubDate>Wed, 15 Jan 2020 01:30:40 +0900</pubDate>
      
      <guid>https://suihan74.github.io/posts/2020/01_15_00_app_dialog_theme_click_outside/</guid>
      <description>Activityをダイアログ表示する android:themeに@style/AppDialogThemeを設定したActivityはダイアログとして表示される。(以下DialogActivityと呼称することにする)
次のはSatenaのブクマ投稿画面を抜粋。
AndroidManifest.xml 62 63 64 65 66  &amp;lt;activity android:name=&amp;#34;.scenes.post2.BookmarkPostActivity&amp;#34; android:theme=&amp;#34;@style/AppDialogTheme&amp;#34;&amp;gt; ... &amp;lt;/activity&amp;gt;   様子 Activityは最前面にダイアログ表示されている。
ダイアログ外側をタップで閉じる DialogActivityの外側は暗くなっていて、この部分をタップするとDialogActivityが閉じて、その下に表示されている画面に処理が戻る。
DialogActivityが何らかの結果を呼び出し元に返すことを期待している場合などに、この「外側タップしてからダイアログが閉じるまでの間」に処理を追加したい、というのが今回の内容である。
関連記事 結果を返すActivityを呼ぶ
閉じる前に処理を追加する onTouchEvent(...)はダイアログ外側のタップにも反応する。
タップされた位置からDialogActivityの外側であることを判別するようにするのが楽そうな解決策だった。
DialogActivity.kt override fun onTouchEvent(event: MotionEvent?): Boolean { // Activityの外側をタップして閉じる際に、結果を渡しておく  if (event?.action == MotionEvent.ACTION_DOWN &amp;amp;&amp;amp; isOutOfBounds(event)) { val intent = Intent().apply { putExtra(RESULT_HOGE, viewModel.hoge.value) } setResult(RESULT_CANCELED, intent) } return super.onTouchEvent(event) } /** Activityの外側をタップしたかを判別する */ private fun isOutOfBounds(event: MotionEvent): Boolean { val x = event.</description>
    </item>
    
    <item>
      <title>はてブ公式がTwitterに共有しているコメントページURLがまた変わっていた件</title>
      <link>https://suihan74.github.io/posts/2020/01_13_00_hatena_entry_url/</link>
      <pubDate>Mon, 13 Jan 2020 13:43:46 +0900</pubDate>
      
      <guid>https://suihan74.github.io/posts/2020/01_13_00_hatena_entry_url/</guid>
      <description>Twitterをぼんやり眺めていたら、1/8頃からはてブの公式アカウントが共有しているコメントページのURLが変わっていたことに気がついたのでメモ。
この記事を書いた直前に一応Satenaにも変更を反映してある。
Satena - はてなブックマーククライアント, はてブビューア
すいはん無料posted withアプリーチ
 内容 今現在使用されているコメントページURLは次の3パターン存在することになる。
パターン2,3は今のところ公式ページでは目にしておらず、SNSに投稿されるリンクに使用されている。
例としてGoogleのトップページ https://www.google.com/ に対するコメントページのURLを扱う。
パターン1 https://b.hatena.ne.jp/entry/s/www.google.com/
要するに、https://b.hatena.ne.jp/entry/ 以下にhttpsなら/s/を加えてスキーム以外の部分を続かせればよい。
はてブページ内ではこの方式が使用されている。
パターン2 https://b.hatena.ne.jp/entry/https://www.google.com/
/entry/以下に対象ページのURLをそのまま突っ込む形。少し前からはてブ公式はこれをTwitterに投稿していた。
パターン1にリダイレクトされる。
パターン3 https://b.hatena.ne.jp/entry?url=https%3A%2F%2Fwww.google.com%2F
今回増えたやつ。クエリパラメータにエンコードした対象ページURLを指定している。
他にも参照元がtwitterであるとかエントリのカテゴリが何であるかといったパラメータが付いているが別に付けなくてもページは開く。
パラメータがないなら対象urlも別にエンコードしてなくても開く。
 正直なんで最初からパターン3じゃないのか謎ではあるが、これに対応させてめでたしめでたし……と思ったら一点問題が。
コメントページのコメントページはどれを使って取得すればいいのか 結論としては、こちら側で「エントリURL→コメントページURL」の変換をするときはパターン1を使うのが無難という感じ。
2階より上に行きたい場合は今調べた限りではこれを使う他ない（？）
○: パターン1を再帰する パターン1にパターン1
https://b.hatena.ne.jp/entry/s/b.hatena.ne.jp/entry/s/www.google.com/
○: パターン3にパターン1のURLを渡す パターン3にパターン1
https://b.hatena.ne.jp/entry?url=https%3A%2F%2Fb.hatena.ne.jp%2Fentry%2Fs%2Fwww.google.com%2F
×: パターン1にパターン3のURLを渡す パターン1にパターン3
https://b.hatena.ne.jp/entry/s/b.hatena.ne.jp/entry?url=https%3A%2F%2Fwww.google.com%2F
×: パターン3にパターン3のURLを渡す 以下のどれも駄目
  パターン3のエンコードされていない部分をエンコード
https://b.hatena.ne.jp/entry?url=https%3A%2F%2Fb.hatena.ne.jp%2Fentry%3Furl%3Dhttps%3A%2F%2Fwww.google.com%2F
  パターン3の全部分をエンコード
https://b.hatena.ne.jp/entry?url=https%3A%2F%2Fb.hatena.ne.jp%2Fentry%3Furl%3Dhttps%253A%252F%252Fwww.google.com%252F
  エンコードしない
https://b.hatena.ne.jp/entry?url=https://b.hatena.ne.jp/entry?url=https://www.google.com/
   どうでもいいけど「パターン」がゲシュタルト崩壊。</description>
    </item>
    
    <item>
      <title>HideBottomViewOnScrollBehaviorの状態を外部から変更する</title>
      <link>https://suihan74.github.io/posts/2020/01_11_00_hide_bottom_view_on_scroll_behavior/</link>
      <pubDate>Sat, 11 Jan 2020 04:30:41 +0900</pubDate>
      
      <guid>https://suihan74.github.io/posts/2020/01_11_00_hide_bottom_view_on_scroll_behavior/</guid>
      <description>関連記事 スクロールで画面上下端のツールバーやボタンを表示/非表示
前提  HideBottomViewOnScrollBehaviorを使用することでコンテンツのスクロールにあわせて画面下部の表示物を表示したり隠したりできる。 protectedメソッドslideDown(child)が呼ばれることで画面下端より下にビューを移動して隠す。slideUp(child)で元の位置に戻して再表示する。  問題 たとえばコンテンツ部分にタブを表示していて、そのコンテンツ部分にはRecyclerViewが配置されているとする。
移動前のタブでスクロールによって画面下部のビュー(以下BottomView)を隠したあとでタブを移動する。
もし移動先のタブにスクロールできるものが無かった場合、そのタブを前面に表示している限りはBottomViewを再表示することができなくなってしまう。
解決方法 タブが変更されたらBottomViewを強制的に再表示するようにする。
そのためには、HideBottomViewOnScrollBehaviorをオーバーライドしてslideDown(...)、slideUp(...)を外から呼べるようにする必要がある。
様子 画面下部FAB部分がタブの切り替えと同時に再表示される。
このFAB部分には以下のExtendedHideBottomViewOnScrollBehavior(相当のもの)をlayoutParams.behaviorに設定している。
ExtendedHideBottomViewOnScrollBehavior.kt package com.suihan74.utilities import android.content.Context import android.util.AttributeSet import android.view.View import com.google.android.material.behavior.HideBottomViewOnScrollBehavior class ExtendedHideBottomViewOnScrollBehavior&amp;lt;V : View&amp;gt;( context: Context?, attrs: AttributeSet? ) : HideBottomViewOnScrollBehavior&amp;lt;V&amp;gt;(context, attrs) { public override fun slideDown(child: V) { super.slideDown(child) } public override fun slideUp(child: V) { super.slideUp(child) } } HogeActivity.kt ... tab_layout.apply { setupWithViewPager(viewPager) addOnTabSelectedListener(object :TabLayout.OnTabSelectedListener { override fun onTabSelected(tab: TabLayout.Tab?) { // タブを切り替えたらBottomViewを再表示する  showButtons() } override fun onTabUnselected(p0: TabLayout.</description>
    </item>
    
    <item>
      <title>外部からprivateなsuspendメソッドを実行する方法</title>
      <link>https://suihan74.github.io/posts/2020/01_09_00_reflection_invoke_suspend/</link>
      <pubDate>Thu, 09 Jan 2020 17:08:19 +0900</pubDate>
      
      <guid>https://suihan74.github.io/posts/2020/01_09_00_reflection_invoke_suspend/</guid>
      <description>プライベートメソッドのテストを書きたいときなどの方法。
Class.getDeclaredMethod(...)を使ってプライベートメソッドを取得して実行する際に気を付けなければいけないことが通常のメソッドに比して少し増える。
実行したいメソッド たとえば以下のようなメソッドをリフレクションでぶっこ抜いてきて実行したいとする。
class Hoge { private suspend fun hoge(foo: Int, bar: String) = withContext(Dispachers.IO) { ... } } メソッドの取得方法 val hogeMethod = Hoge::class.java.getDeclaredMethod( &amp;#34;hoge&amp;#34;, Int::class.java, String::class.java, Continuation::class.java ).apply { isAccessible = true } 引数型の最後にContinuation::class.javaを記述する必要がある。
取得したメソッドの実行方法 次のような拡張メソッドを用意しておく（とまぁ便利）。
suspend fun Method.invokeSuspend(obj: Any, vararg args: Any?) : Any? = suspendCoroutineUninterceptedOrReturn { cont -&amp;gt; invoke(obj, *args, cont) } インスタンスと引数を渡して実行する。
hogeMethod.invokeSuspend(instance, 0, &amp;#34;hoge&amp;#34;) テストでこの処理結果を受けてassertEquals(...)とかしたい場合は、
runBlockingするなりして終了を待機しておけばいいんだろうか。
いい感じの方法が他にあれば知りたい。
 参考
java - How to run suspend method via reflection?</description>
    </item>
    
    <item>
      <title>結果を返すActivityを呼ぶ</title>
      <link>https://suihan74.github.io/posts/2020/01_07_00_start_activity_for_result/</link>
      <pubDate>Tue, 07 Jan 2020 03:02:05 +0900</pubDate>
      
      <guid>https://suihan74.github.io/posts/2020/01_07_00_start_activity_for_result/</guid>
      <description>Activityから戻ってくる際にその結果を受け取る必要がある場合のやりかた。
こういうネタ何書いても今さら感しかないわけだけど、しかし作っているもの的にこれまであまり必要なシーンも無かったので、備忘。
1. 結果を返すActivityの呼び方 startActivity(intent)の代わりにstartActivityForResult(intent: Intent, requestCode: Int)を使用する。
startActivityForResult(intent, HogeActivity.REQUEST_CODE) requestCodeはInt型だが16bit範囲内の値である必要がある1。
これを守らないとIllegalArgumentException投げられる。
定数値以外を使う場合0xffffでマスクするなりしてナントカする。
Fragmentから呼んで、返ってきた結果をActivityで処理する場合 Fragment.startActivityForResult(...)を使用するとActivity.onActivityResult(...)に渡されるrequestCodeが意図しないものになる。
以下のどちらかで対応。
 Activityで結果を受け取りたいならactivity?.startActivityForResult(...)とかに書き換える。 Fragment.onActivityResult(...)で受け取る。  2. Activityから結果を返して終了する Activity.finish()を呼ぶ前にresultCodeと結果を返すためのIntentをセットする。
val intent = Intent().apply { putExtra(RESULT_DATA, result) } setResult(Activity.RESULT_OK, intent) finish() 成功ならActivity.RESULT_OK、失敗ならActivity.RESULT_CANCELEDがあるのでそれを使えばそれで良い気がする。
何も指定しないとActivity.RESULT_CANCELEDが返ってくるっぽい。
3. 返ってきた結果を受け取る override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) when (requestCode) { HogeActivity.REQUEST_CODE -&amp;gt; { when (resultCode) { Activity.RESULT_OK -&amp;gt; { val result = data?.getSerializableExtra(HogeActivity.RESULT_DATA) as? HogeResult ... } Activity.</description>
    </item>
    
    <item>
      <title>LinkMovementMethodを設定したTextViewの文字列選択を解除するとクラッシュする</title>
      <link>https://suihan74.github.io/posts/2020/01_06_01_selectable_textview/</link>
      <pubDate>Mon, 06 Jan 2020 02:49:08 +0900</pubDate>
      
      <guid>https://suihan74.github.io/posts/2020/01_06_01_selectable_textview/</guid>
      <description>問題 以下の条件のTextViewを用意する。
 movementMethodにLinkMovementMethodを設定する。 android:textIsSelectable=&amp;quot;true&amp;quot;を設定する。  そして以下の手順で操作を行うと、アプリがクラッシュする。
 該当TextViewの文字列を選択する。 TextView上の適当な領域をタップして文字列選択を解除する。 破滅する。  ちなみに、
LinkMovementMethodのreturn super.onTouchEvent(...)の部分にブレークポイントを置いてから文字列選択解除すると発生しなくてなんやねんってなった。
また、解除時のタップは単押し長押しに関わらずとにかくMotionEvent.ACTION_DOWNがきた時点で駄目っぽかった。
様子 ログ java.lang.IllegalArgumentException: Invalid offset: -1. Valid range is [0, 16] at android.text.method.WordIterator.checkOffsetIsValid(WordIterator.java:380) at android.text.method.WordIterator.isBoundary(WordIterator.java:101) at android.widget.Editor$SelectionStartHandleView.positionAtCursorOffset(Editor.java:4260) at android.widget.Editor$HandleView.updatePosition(Editor.java:3708) at android.widget.Editor$PositionListener.onPreDraw(Editor.java:2507) at android.view.ViewTreeObserver.dispatchOnPreDraw(ViewTreeObserver.java:944) at android.view.ViewRootImpl.performTraversals(ViewRootImpl.java:2055) at android.view.ViewRootImpl.doTraversal(ViewRootImpl.java:1107) at android.view.ViewRootImpl$TraversalRunnable.run(ViewRootImpl.java:6013) at android.view.Choreographer$CallbackRecord.run(Choreographer.java:858) at android.view.Choreographer.doCallbacks(Choreographer.java:670) at android.view.Choreographer.doFrame(Choreographer.java:606) at android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:844) at android.os.Handler.handleCallback(Handler.java:739) at android.os.Handler.dispatchMessage(Handler.java:95) at android.os.Looper.loop(Looper.java:148) at android.app.ActivityThread.main(ActivityThread.java:5417) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616) 「オフセット: -1を選択しようとしてますね」じゃねぇんじゃ。</description>
    </item>
    
    <item>
      <title>タイトルテキストがMarqueeするToolbarを作る</title>
      <link>https://suihan74.github.io/posts/2020/01_06_00_marquee_toolbar/</link>
      <pubDate>Mon, 06 Jan 2020 00:18:01 +0900</pubDate>
      
      <guid>https://suihan74.github.io/posts/2020/01_06_00_marquee_toolbar/</guid>
      <description>やりたいこと こういうの。
ツールバーのtitle部分の文字列が横に流れ続けている。
カスタムビューの作成 Toolbarを継承した次のようなカスタムビューを作成する。
MarqueeToolbar.kt package com.suihan74.utilities import android.content.Context import android.text.TextUtils import android.util.AttributeSet import android.widget.TextView import androidx.appcompat.widget.Toolbar class MarqueeToolbar : Toolbar { constructor(context: Context, attributeSet: AttributeSet? = null) : super(context, attributeSet) constructor(context: Context, attributeSet: AttributeSet?, defStyleAttr: Int) : super(context, attributeSet, defStyleAttr) /** タイトルの設定が完了しているか否か */ private var reflected: Boolean = false /** タイトル部分のTextView */ private var titleTextView: TextView? = null override fun setTitle(resId: Int) { if (!reflected) { reflected = reflectTitle() } super.</description>
    </item>
    
    <item>
      <title>スクロールで画面上下端のツールバーやボタンを表示/非表示</title>
      <link>https://suihan74.github.io/posts/2020/01_02_02_show_views_with_scrolling/</link>
      <pubDate>Fri, 03 Jan 2020 00:12:34 +0900</pubDate>
      
      <guid>https://suihan74.github.io/posts/2020/01_02_02_show_views_with_scrolling/</guid>
      <description>やること こういうやつ。
画面中央のRecyclerViewのスクロールに合わせて、画面上端のToolbarが上に向かって隠れ、画面下端のFloatingActionButton(を複数持ったFragment)が下に向かって隠れている。
レイアウトで指定する場合 レイアウト側で設定する場合は以下のようにする。
Satenaで実際に使っているレイアウトファイルだが、必要な部分だけ適当に抜粋した。
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; xmlns:app=&amp;#34;http://schemas.android.com/apk/res-auto&amp;#34; android:background=&amp;#34;?attr/panelBackground&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34;&amp;gt; &amp;lt;com.google.android.material.appbar.AppBarLayout android:id=&amp;#34;@+id/appbar_layout&amp;#34; app:elevation=&amp;#34;0dp&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34;&amp;gt; &amp;lt;androidx.appcompat.widget.Toolbar android:id=&amp;#34;@+id/toolbar&amp;#34; app:layout_scrollFlags=&amp;#34;enterAlways|scroll&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34;/&amp;gt; &amp;lt;/com.google.android.material.appbar.AppBarLayout&amp;gt; &amp;lt;!--ブクマリストを表示するための領域 --&amp;gt; &amp;lt;FrameLayout android:id=&amp;#34;@+id/content_layout&amp;#34; app:layout_behavior=&amp;#34;com.google.android.material.appbar.AppBarLayout$ScrollingViewBehavior&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34;/&amp;gt; &amp;lt;!--ブクマリスト用下部ボタンを表示するための領域 --&amp;gt; &amp;lt;FrameLayout android:id=&amp;#34;@+id/buttons_layout&amp;#34; app:layout_behavior=&amp;#34;com.google.android.material.behavior.HideBottomViewOnScrollBehavior&amp;#34; android:layout_gravity=&amp;#34;bottom&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34;/&amp;gt; &amp;lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&amp;gt; FrameLayout部分にそれぞれコンテンツ内容にあたるFragmentがreplaceされる。
@id/content_layoutには主にRecyclerViewが配置されたフラグメントを複数タブとして持つフラグメントが置かれ、
@id/buttons_layoutにはFloatingActionButtonが配置されている。
ちなみに、AppBarLayoutにapp:elevation=&amp;quot;0dp&amp;quot;が設定されているのは、こうすることで@id/content_layoutのフラグメントがもつTabLayoutとの間に不要な影が描画されなくなるため。
トリガー スクロールを監視して他のViewを隠すトリガーにしたい対象(@id/content_layoutがそれにあたる)には、
app:layout_behavior=&amp;#34;com.google.android.material.appbar.AppBarLayout$ScrollingViewBehavior&amp;#34; を設定する。
ツールバー AppBarLayout内のViewをスクロールに合わせて画面上部に隠すには、
app:layout_scrollFlags=&amp;#34;enterAlways|scroll&amp;#34; とか設定する。app:layout_scrollFlagsの値による差異については以下などを見ればいいように思う。
Android Design — Collapsing Toolbar: ScrollFlags Illustrated
ボトムナビゲーション HideBottomViewOnScrollBehaviorというまんまな名前のBehaviorがあるのでこれを設定すると、スクロールに合わせて画面下部に向かってViewが隠れる。
app:layout_behavior=&amp;#34;com.google.android.material.behavior.HideBottomViewOnScrollBehavior&amp;#34; コードで指定する場合 設定値にあわせて表示切替をしたりしなかったりを動的に設定したい場合など、DataBindingとかしようと思わないならActivityなり何なりにkotlin側で記述することもできる。
次の例では、(少し手を加えた)SharedPreferencesの設定値によって画面上下端のViewの表示切替をするかしないかをコード側で設定している。
// スクロールでツールバーを隠す toolbar.updateLayoutParams&amp;lt;AppBarLayout.LayoutParams&amp;gt; { scrollFlags = if (prefs.</description>
    </item>
    
    <item>
      <title>AlertDialogにスタイルが適用されなくて無邪気におかしいなとか思った話</title>
      <link>https://suihan74.github.io/posts/2020/01_02_01_androidx_alert_dialog/</link>
      <pubDate>Thu, 02 Jan 2020 22:15:23 +0900</pubDate>
      
      <guid>https://suihan74.github.io/posts/2020/01_02_01_androidx_alert_dialog/</guid>
      <description>android:接頭辞のつく属性はサポートライブラリのスタイルには使わない。
以上。
発生した問題   AlertDialogを使うときに、うっかりandroidx.appcompat.app.AlertDialogとandroid.app.AlertDialogを混在させていた。
  そのどちらでも共通のスタイルを使用していた。
  アプリで使用するダイアログで下部ボタン（Positive, Negative, Neutral）の色がちゃんとスタイル適用されるものとされないものがあった。
  原因  注: サポート ライブラリの属性名は、android: 接頭辞を使用しません。これは Android フレームワークの属性にのみ使用します。
 スタイルとテーマ | Android Developers
はい切腹しますありがとうございました。
修正   すべてのAlertDialogインポート部分をandroidx.appcompat.app.AlertDialogに統一。
  ボタンスタイルを次のように指定。
  &amp;lt;item name=&amp;#34;buttonBarPositiveButtonStyle&amp;#34;&amp;gt;@style/PositiveButtonStyle&amp;lt;/item&amp;gt; &amp;lt;item name=&amp;#34;buttonBarNegativeButtonStyle&amp;#34;&amp;gt;@style/NegativeButtonStyle&amp;lt;/item&amp;gt; &amp;lt;item name=&amp;#34;buttonBarNeutralButtonStyle&amp;#34;&amp;gt;@style/NeutralButtonStyle&amp;lt;/item&amp;gt; </description>
    </item>
    
    <item>
      <title>Android - DataBindingはじめ</title>
      <link>https://suihan74.github.io/posts/2020/01_02_00_beginning_of_data_binding/</link>
      <pubDate>Thu, 02 Jan 2020 17:04:24 +0900</pubDate>
      
      <guid>https://suihan74.github.io/posts/2020/01_02_00_beginning_of_data_binding/</guid>
      <description>最近ずっとSatenaのActivity/Fragmentのコード側を作り直す作業をしていて、ViewModel + LiveDataは割と活用してきて&amp;quot;前よりは&amp;quot;いい感じになってきているのだが、
DataBindingに関しては以前UWPアプリ作るとき（中途半端に）触れて以来、MVVMというかデータバインディングやったらやったでそれはそれで色々と面倒なことがあるイメージがあったので積極的に取り入れてなかったのだけど、楽できそうな部分ではやっていこうかと唐突に思った。
今さら感強い上にまだ詳しく使い込んでいないので、
とりあえず導入的なものと、
主に忘れそうな部分についていくつかメモを書く。
導入 build.gradle (app) ViewModelやらDataBindingを使用するのに必要な設定・依存関係を追加する。
android { ... // DataBinding利用に必要  dataBinding { enabled = true } ... } dependencies { ... // ViewModel and LiveData  def lifecycle_version = &amp;#34;2.1.0&amp;#34; implementation &amp;#34;androidx.lifecycle:lifecycle-extensions:$lifecycle_version&amp;#34; implementation &amp;#34;androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version&amp;#34; implementation &amp;#34;androidx.lifecycle:lifecycle-common-java8:$lifecycle_version&amp;#34; testImplementation &amp;#34;androidx.arch.core:core-testing:$lifecycle_version&amp;#34; ... } activity_hoge.xml 以前のレイアウトの内容を&amp;lt;layout&amp;gt;で囲い、&amp;lt;data&amp;gt; ~ &amp;lt;/data&amp;gt;にバインドに必要な情報を記述する。
ここでは、コード側で用意してバインドするViewModelのオブジェクトをレイアウトファイル内ではvmとして扱う。
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;layout xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34;&amp;gt; &amp;lt;!--bindするデータ --&amp;gt; &amp;lt;data&amp;gt; &amp;lt;variable name=&amp;#34;vm&amp;#34; type=&amp;#34;com.suihan74.hoge.HogeViewModel&amp;#34; /&amp;gt; &amp;lt;/data&amp;gt; &amp;lt;!--以下表示部分 --&amp;gt; &amp;lt;androidx.coordinatorlayout.widget.CoordinatorLayout android:id=&amp;#34;@+id/hoge_layout&amp;#34; android:background=&amp;#34;?attr/panelBackground&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34;&amp;gt; .</description>
    </item>
    
  </channel>
</rss>